<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cal Poly NFPA Vehicle Challenge: Interface.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cal Poly NFPA Vehicle Challenge
   &#160;<span id="projectnumber">Soulenoid Cycle, 2021.</span>
   </div>
   <div id="projectbrief">Support documentation for various mechatronics components on the vehicle.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('Interface_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Interface.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Interface_8h_source.html">Interface.h</a>&quot;</code><br />
<code>#include &quot;taskshare.h&quot;</code><br />
<code>#include &quot;taskqueue.h&quot;</code><br />
<code>#include &quot;EasyNextionLibrary.h&quot;</code><br />
<code>#include &quot;STM32FreeRTOS.h&quot;</code><br />
<code>#include &quot;SPI.h&quot;</code><br />
<code>#include &quot;mcp2515.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a615d19d041ac08f3856b236b7a8e35e6"><td class="memItemLeft" align="right" valign="top"><a id="a615d19d041ac08f3856b236b7a8e35e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a615d19d041ac08f3856b236b7a8e35e6">coastButton</a>&#160;&#160;&#160;PA15</td></tr>
<tr class="memdesc:a615d19d041ac08f3856b236b7a8e35e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin attached to coast button. <br /></td></tr>
<tr class="separator:a615d19d041ac08f3856b236b7a8e35e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a64b24d507d8ddff6aa9fb1e2a4879d"><td class="memItemLeft" align="right" valign="top"><a id="a8a64b24d507d8ddff6aa9fb1e2a4879d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a8a64b24d507d8ddff6aa9fb1e2a4879d">directButton</a>&#160;&#160;&#160;PB3</td></tr>
<tr class="memdesc:a8a64b24d507d8ddff6aa9fb1e2a4879d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin attached to direct drive button. <br /></td></tr>
<tr class="separator:a8a64b24d507d8ddff6aa9fb1e2a4879d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d1368f9c3604c940ee0d2c2d6e5d5f"><td class="memItemLeft" align="right" valign="top"><a id="a81d1368f9c3604c940ee0d2c2d6e5d5f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a81d1368f9c3604c940ee0d2c2d6e5d5f">boostButton</a>&#160;&#160;&#160;PB4</td></tr>
<tr class="memdesc:a81d1368f9c3604c940ee0d2c2d6e5d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin attached to boost mode button. <br /></td></tr>
<tr class="separator:a81d1368f9c3604c940ee0d2c2d6e5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f61c5c02d0fdae4e4085521c810c37"><td class="memItemLeft" align="right" valign="top"><a id="a19f61c5c02d0fdae4e4085521c810c37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a19f61c5c02d0fdae4e4085521c810c37">regenButton</a>&#160;&#160;&#160;PB5</td></tr>
<tr class="memdesc:a19f61c5c02d0fdae4e4085521c810c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin attached to regenerative braking button. <br /></td></tr>
<tr class="separator:a19f61c5c02d0fdae4e4085521c810c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe94cf4e3630fe1c4a543d69b0cd01a6"><td class="memItemLeft" align="right" valign="top"><a id="abe94cf4e3630fe1c4a543d69b0cd01a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#abe94cf4e3630fe1c4a543d69b0cd01a6">HALL1</a>&#160;&#160;&#160;PB12</td></tr>
<tr class="memdesc:abe94cf4e3630fe1c4a543d69b0cd01a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin attached to hall effect sensor. <br /></td></tr>
<tr class="separator:abe94cf4e3630fe1c4a543d69b0cd01a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3780e2fe762dc532df7d0f030b55caa0"><td class="memItemLeft" align="right" valign="top"><a id="a3780e2fe762dc532df7d0f030b55caa0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a3780e2fe762dc532df7d0f030b55caa0">CS</a>&#160;&#160;&#160;PA4</td></tr>
<tr class="memdesc:a3780e2fe762dc532df7d0f030b55caa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition for GPIO pin atached to the MCP2515 chip select. <br /></td></tr>
<tr class="separator:a3780e2fe762dc532df7d0f030b55caa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af090274e5f1ebfc12cc507560a557ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#af090274e5f1ebfc12cc507560a557ce7">debounce</a> (uint8_t buttonPin, uint8_t length, bool sign=true)</td></tr>
<tr class="memdesc:af090274e5f1ebfc12cc507560a557ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to debounce a signal from a GPIO pin.  <a href="Interface_8cpp.html#af090274e5f1ebfc12cc507560a557ce7">More...</a><br /></td></tr>
<tr class="separator:af090274e5f1ebfc12cc507560a557ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e4b01ae4853571688d2e30c1db7265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a66e4b01ae4853571688d2e30c1db7265">ISRcoast</a> ()</td></tr>
<tr class="memdesc:a66e4b01ae4853571688d2e30c1db7265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for the coast mode button.  <a href="Interface_8cpp.html#a66e4b01ae4853571688d2e30c1db7265">More...</a><br /></td></tr>
<tr class="separator:a66e4b01ae4853571688d2e30c1db7265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d676688a39ec76b704f66d37964e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a76d676688a39ec76b704f66d37964e09">ISRdirect</a> ()</td></tr>
<tr class="memdesc:a76d676688a39ec76b704f66d37964e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for the direct drive button.  <a href="Interface_8cpp.html#a76d676688a39ec76b704f66d37964e09">More...</a><br /></td></tr>
<tr class="separator:a76d676688a39ec76b704f66d37964e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46403aac21bdccea79e1beecd864128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#ac46403aac21bdccea79e1beecd864128">ISRboost</a> ()</td></tr>
<tr class="memdesc:ac46403aac21bdccea79e1beecd864128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for the boost mode button.  <a href="Interface_8cpp.html#ac46403aac21bdccea79e1beecd864128">More...</a><br /></td></tr>
<tr class="separator:ac46403aac21bdccea79e1beecd864128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a28ee5726339c4533548dc530634295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a4a28ee5726339c4533548dc530634295">ISRregen</a> ()</td></tr>
<tr class="memdesc:a4a28ee5726339c4533548dc530634295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt service routine for the regen mode button.  <a href="Interface_8cpp.html#a4a28ee5726339c4533548dc530634295">More...</a><br /></td></tr>
<tr class="separator:a4a28ee5726339c4533548dc530634295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8686a378ae63586440852b7a15bf41e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#aa8686a378ae63586440852b7a15bf41e">CAN_sendPress</a> (MCP2515 &amp;node)</td></tr>
<tr class="memdesc:aa8686a378ae63586440852b7a15bf41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to transmit the current button state to the PLC.  <a href="Interface_8cpp.html#aa8686a378ae63586440852b7a15bf41e">More...</a><br /></td></tr>
<tr class="separator:aa8686a378ae63586440852b7a15bf41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b4ba8037c51907ef76cdd1c2854fae"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#ae7b4ba8037c51907ef76cdd1c2854fae">CAN_readPressure</a> (MCP2515 &amp;node)</td></tr>
<tr class="memdesc:ae7b4ba8037c51907ef76cdd1c2854fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read the accumulator pressure from the PLC.  <a href="Interface_8cpp.html#ae7b4ba8037c51907ef76cdd1c2854fae">More...</a><br /></td></tr>
<tr class="separator:ae7b4ba8037c51907ef76cdd1c2854fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc2703fa5ce6fe2e51c0ff064aff495"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a6fc2703fa5ce6fe2e51c0ff064aff495">calculatePressure</a> (int32_t sensorReading)</td></tr>
<tr class="memdesc:a6fc2703fa5ce6fe2e51c0ff064aff495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calculates a pressure, in psi, based on a raw sensor reading. <br  />
  <a href="Interface_8cpp.html#a6fc2703fa5ce6fe2e51c0ff064aff495">More...</a><br /></td></tr>
<tr class="separator:a6fc2703fa5ce6fe2e51c0ff064aff495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758e3e40f550649d6594bb1c53073dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a758e3e40f550649d6594bb1c53073dcc">updateDriveMode</a> (EasyNex &amp;display)</td></tr>
<tr class="memdesc:a758e3e40f550649d6594bb1c53073dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the drive mode on the Nextion.  <a href="Interface_8cpp.html#a758e3e40f550649d6594bb1c53073dcc">More...</a><br /></td></tr>
<tr class="separator:a758e3e40f550649d6594bb1c53073dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33e4972e861b45fe133b914aaec9677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#ab33e4972e861b45fe133b914aaec9677">task_display</a> (void *p_params)</td></tr>
<tr class="memdesc:ab33e4972e861b45fe133b914aaec9677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task which interacts with the Nextion display.  <a href="Interface_8cpp.html#ab33e4972e861b45fe133b914aaec9677">More...</a><br /></td></tr>
<tr class="separator:ab33e4972e861b45fe133b914aaec9677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f82a9baaed0c34653d7fab2740099d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a1f82a9baaed0c34653d7fab2740099d1">task_CAN</a> (void *p_params)</td></tr>
<tr class="memdesc:a1f82a9baaed0c34653d7fab2740099d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task which interacts with the CAN bus.  <a href="Interface_8cpp.html#a1f82a9baaed0c34653d7fab2740099d1">More...</a><br /></td></tr>
<tr class="separator:a1f82a9baaed0c34653d7fab2740099d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d50525ab6bbea9007958d7feaf83360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360">task_HALL1</a> (void *p_params)</td></tr>
<tr class="memdesc:a6d50525ab6bbea9007958d7feaf83360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task which reads a hall effect sensor.  <a href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360">More...</a><br /></td></tr>
<tr class="separator:a6d50525ab6bbea9007958d7feaf83360"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a39a067cd169642a9dc6f35d61e74a949"><td class="memItemLeft" align="right" valign="top"><a id="a39a067cd169642a9dc6f35d61e74a949"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a39a067cd169642a9dc6f35d61e74a949">buttonState</a> = 1</td></tr>
<tr class="memdesc:a39a067cd169642a9dc6f35d61e74a949"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable keeps track of which drive mode the vehicle is in. This value is when a button is pressed. <br /></td></tr>
<tr class="separator:a39a067cd169642a9dc6f35d61e74a949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e421ccb26cae296438098ad2a743b"><td class="memItemLeft" align="right" valign="top"><a id="ab85e421ccb26cae296438098ad2a743b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#ab85e421ccb26cae296438098ad2a743b">previousButtonState_DSP</a> = 255</td></tr>
<tr class="memdesc:ab85e421ccb26cae296438098ad2a743b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is changed by the display task, and keeps track of when the drive mode text on the Nextion display needs to be updated. <br /></td></tr>
<tr class="separator:ab85e421ccb26cae296438098ad2a743b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46709bdab87c13ff4c0a5a41e69b2cca"><td class="memItemLeft" align="right" valign="top"><a id="a46709bdab87c13ff4c0a5a41e69b2cca"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a46709bdab87c13ff4c0a5a41e69b2cca">previousButtonState_CAN</a> = 255</td></tr>
<tr class="memdesc:a46709bdab87c13ff4c0a5a41e69b2cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is changed by the CAN task, and keeps track of when the controller needs to push an update to the PLC. <br /></td></tr>
<tr class="separator:a46709bdab87c13ff4c0a5a41e69b2cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7e37eb41ab30ce2710027597139689"><td class="memItemLeft" align="right" valign="top">Share&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a7a7e37eb41ab30ce2710027597139689">accumulatorPressure</a></td></tr>
<tr class="memdesc:a7a7e37eb41ab30ce2710027597139689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter-task variable for storing accumulator pressure values.  <a href="Interface_8cpp.html#a7a7e37eb41ab30ce2710027597139689">More...</a><br /></td></tr>
<tr class="separator:a7a7e37eb41ab30ce2710027597139689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51293a47184005045b60439ff7c77a22"><td class="memItemLeft" align="right" valign="top">Share&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a51293a47184005045b60439ff7c77a22">bikeSpeed</a></td></tr>
<tr class="memdesc:a51293a47184005045b60439ff7c77a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter-task variable for storing bike speed values.  <a href="Interface_8cpp.html#a51293a47184005045b60439ff7c77a22">More...</a><br /></td></tr>
<tr class="separator:a51293a47184005045b60439ff7c77a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333f898c62a70650d62a55626c12a6be"><td class="memItemLeft" align="right" valign="top">Share&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a333f898c62a70650d62a55626c12a6be">floatSpeed</a></td></tr>
<tr class="memdesc:a333f898c62a70650d62a55626c12a6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter-task variable for storing "float" speed values.  <a href="Interface_8cpp.html#a333f898c62a70650d62a55626c12a6be">More...</a><br /></td></tr>
<tr class="separator:a333f898c62a70650d62a55626c12a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f55d9204fc41e23568a392aab638239"><td class="memItemLeft" align="right" valign="top">Share&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Interface_8cpp.html#a6f55d9204fc41e23568a392aab638239">CANconnected</a></td></tr>
<tr class="memdesc:a6f55d9204fc41e23568a392aab638239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share that stores status of CAN connection.  <a href="Interface_8cpp.html#a6f55d9204fc41e23568a392aab638239">More...</a><br /></td></tr>
<tr class="separator:a6f55d9204fc41e23568a392aab638239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the function files for the RTOS tasks used with the interface controller. It manages three tasks: display, CAN, and hall effect. In the display task, the controller interfaces with a Nextion display using the EasyNextionLibrary header file. The controller communicates with the Nextion using UART. In the CAN task, the controller interfaces with an MCP2515 CAN controller using SPI, which outputs a CAN signal to the CAN bus. In the hall effect task, the controller reads a GPIO pin using a polling method.</p>
<p>As discussed in the section, <a class="el" href="index.html#s_software">Software Design</a>, the task with the highest priority is <a class="el" href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360" title="Task which reads a hall effect sensor.">task_HALL1()</a>, which must quickly poll the hall effect sensor to measure the speed of the vehicle. A high-level task diagram is shown in Figure 1.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fig19.png" alt="" style="width:400px;" class="inline"/> <br  />
<b>Figure 1.</b> Inter-controller system boundary diagram.</p>
<p>The sensor task, <a class="el" href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360" title="Task which reads a hall effect sensor.">task_HALL1()</a> operates in a simple Finite State Machine (FSM) that switches states based on the high/low status of the hall effect signal. An FSM diagram is shown in the figure below.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/fsm.png" alt="" style="width:400px;" class="inline"/> <br  />
<b>Figure 2.</b> FSM diagram for <a class="el" href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360" title="Task which reads a hall effect sensor.">task_HALL1()</a>.</p>
<p>In State 1, the task continuously waits for a hall effect trigger. Since the sensor is active-low, the task uses the function <a class="el" href="Interface_8cpp.html#af090274e5f1ebfc12cc507560a557ce7" title="Function to debounce a signal from a GPIO pin.">debounce()</a> to identify when the signal transitions from high to low. When this change is identified, the task calculates the speed of the vehicle and stores it in two inter-task variables: bikeSpeed and floatSpeed. See variable descriptions for more information. After the speed is calculated, the task transitions to State 2 to wait until the signal transitions back to high. When the signal returns from low to high, the task transitions back to State 1 to wait for the next pulse.</p>
<dl class="section author"><dt>Author</dt><dd>Jordan Kochavi </dd></dl>
<dl class="section date"><dt>Date</dt><dd>8 Dec 2020 Original file </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6fc2703fa5ce6fe2e51c0ff064aff495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc2703fa5ce6fe2e51c0ff064aff495">&#9670;&nbsp;</a></span>calculatePressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t calculatePressure </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sensorReading</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that calculates a pressure, in psi, based on a raw sensor reading. <br  />
 </p>
<p>The pressure transducer that is connected to the ECDR 0506-A is configured to output an analog voltage, ranging from 0.5 - 4.5 Vdc. When the controller receives input from this sensor, it interpret's the sensor's reading as an integer ranging from 0 - 5000, which represents 0 - 5 Volts. Therefore, the output of <a class="el" href="Interface_8cpp.html#ae7b4ba8037c51907ef76cdd1c2854fae" title="Function to read the accumulator pressure from the PLC.">CAN_readPressure()</a> will always be an integer ranging from 500 - 4500. When the pressure outputs its maximum voltage, which is 4.5 Volts, it reads its maximum pressure of 5000 psi. When it outputs its minimum voltage, which is 0.5 Volts, it reads its minimum pressure, which is 0 psi. Using these constraints, a linear gain and offset were determined. The gain has a value of 1.25, with an offset of 625. After applying these transformations to convert the raw sensor reading into a pressure measurement, this function saturates the calculation between 0 and 5000 psi. A plot of the pressure transducer calibration curve is shown in the graph below.</p>
<p><img src="https://raw.githubusercontent.com/jkochavi/Fluid-Power-Controller/master/wiki_Support_Files/pressureTransducer.png" alt="" style="width:400px;" class="inline"/></p>
<p>The curve was obtained from the minimum and maximum voltage outputs, as reflected in the pressure transducer's datasheet. During testing, the linear relationship above was determined to have an exactly 100 psi offset from the analog pressure gauge on the vehicle. This offset was accounted for in this function. <br  />
 The pressure transducer is installed in the hydraulic manifold. It is an Ashcroft G2 pressure transmitter. Its datasheet and wiring details are available at <a href="https://ashcroft.eu/pictures/pdf/manual-transducers-G2-T2.pdf"><b>this link</b></a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorReading</td><td>The output of <a class="el" href="Interface_8cpp.html#ae7b4ba8037c51907ef76cdd1c2854fae" title="Function to read the accumulator pressure from the PLC.">CAN_readPressure()</a>. An integer between 0 and 5000. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pressure measurement, in psi, as a signed 32-bit integer. </dd></dl>

</div>
</div>
<a id="ae7b4ba8037c51907ef76cdd1c2854fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b4ba8037c51907ef76cdd1c2854fae">&#9670;&nbsp;</a></span>CAN_readPressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CAN_readPressure </td>
          <td>(</td>
          <td class="paramtype">MCP2515 &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read the accumulator pressure from the PLC. </p>
<p>This function reads the CAN bus for the accumulator pressure. The PLC transmits a pressure reading in a 2 byte message with ID 0x181, another arbitrary hex number. The message needs to be 2 bytes long because the accumulator pressure can be up to 3000 psi, which requires 2 bytes. To retrieve the measurement, we need to read each byte, one at a time. The PLC sends the low byte first, and then the second. After we read both bytes of data, we concatenate them into a single number by left-shifting the high byte by 8, and adding it to the low byte. The function returns a 32-bit integer for printing to the Nextion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The MCP2515 controller that we are interfacing with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A signed 32-bit integer containing the analog output of the pressure transducer. This integer carries units of millivolts. </dd></dl>

</div>
</div>
<a id="aa8686a378ae63586440852b7a15bf41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8686a378ae63586440852b7a15bf41e">&#9670;&nbsp;</a></span>CAN_sendPress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_sendPress </td>
          <td>(</td>
          <td class="paramtype">MCP2515 &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to transmit the current button state to the PLC. </p>
<p>This function sends a CAN message to the CAN bus based on the current button state. This function only transmits a message if a button was recently pressed. To do this, we use the global variable previousButtonState_CAN, which changes only when buttonState changes. This way, we only send one transmission to the CAN bus whenever a button is pressed, instead of continuously. To sent the message, we construct a CAN message that is only one byte long, with the ID of 0x181, an arbitrary hex number. On the other end, the PLC will first read the ID of the message, and then interpret its data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The MCP2515 controller that we are interfacing with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af090274e5f1ebfc12cc507560a557ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af090274e5f1ebfc12cc507560a557ce7">&#9670;&nbsp;</a></span>debounce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool debounce </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buttonPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sign</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to debounce a signal from a GPIO pin. </p>
<p>This function reads the value from a GPIO pin for a user-specified duration to prevent signal noise. When a drive mode button is pressed, we need to ensure that the rider is pressing a button intentionally, instead of an accidental press or noise from vibration. This function returns true if the function takes enough readings to conclude that a button has been pressed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonPin</td><td>The GPIO pin to read. </td></tr>
    <tr><td class="paramname">length</td><td>How many readings to take to debounce the signal. </td></tr>
    <tr><td class="paramname">sign</td><td>Which signal to look for: active-high or active-low. This parameter is TRUE by default, which debounces an active-high signal. If FALSE is passed here, then this method will debounce an active-low signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean. A debounced trigger returns TRUE. Otherwise, it returns FALSE. </dd></dl>

</div>
</div>
<a id="ac46403aac21bdccea79e1beecd864128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46403aac21bdccea79e1beecd864128">&#9670;&nbsp;</a></span>ISRboost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISRboost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for the boost mode button. </p>
<p>This function is triggered by the rising edge of the signal from the boost button GPIO pin. First, it debounces the signal to make sure that the button was actually pressed, then it sets buttonState accordingly. </p>

</div>
</div>
<a id="a66e4b01ae4853571688d2e30c1db7265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e4b01ae4853571688d2e30c1db7265">&#9670;&nbsp;</a></span>ISRcoast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISRcoast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for the coast mode button. </p>
<p>This function is triggered by the rising edge of the signal from the coast button GPIO pin. First, it debounces the signal to make sure that the button was actually pressed, then it sets buttonState accordingly. </p>

</div>
</div>
<a id="a76d676688a39ec76b704f66d37964e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d676688a39ec76b704f66d37964e09">&#9670;&nbsp;</a></span>ISRdirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISRdirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for the direct drive button. </p>
<p>This function is triggered by the rising edge of the signal from the direct drive button GPIO pin. First, it debounces the signal to make sure that the button was actually pressed, then it sets buttonState accordingly. </p>

</div>
</div>
<a id="a4a28ee5726339c4533548dc530634295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a28ee5726339c4533548dc530634295">&#9670;&nbsp;</a></span>ISRregen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISRregen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt service routine for the regen mode button. </p>
<p>This function is triggered by the rising edge of the signal from the regen button GPIO pin. First, it debounces the signal to make sure that the button was actually pressed, then it sets buttonState accordingly. </p>

</div>
</div>
<a id="a1f82a9baaed0c34653d7fab2740099d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f82a9baaed0c34653d7fab2740099d1">&#9670;&nbsp;</a></span>task_CAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_CAN </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task which interacts with the CAN bus. </p>
<p>This task sends the current user-chosen drive mode to the PLC, and reads the accumulator pressure, using the CAN bus. We interface with the CAN bus using an MCP2515 controller. On the custom PCB, the MCP2515 controller uses an 8 MHz crystal to clock the CAN bitrate. However, the mcp2515.cpp and mcp2515.h files clock the bitrate using a 16 MHz crystal. This parameter was altered in those files to set the correct bitrate. That modification is not documented, as the files are from a different source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_params</td><td>A pointer to function parameters which we don't use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab33e4972e861b45fe133b914aaec9677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33e4972e861b45fe133b914aaec9677">&#9670;&nbsp;</a></span>task_display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_display </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task which interacts with the Nextion display. </p>
<p>This task updates various data on the Nextion, which includes the accumulator pressure and the speed of the vehicle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_params</td><td>A pointer to function parameters which we don't use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d50525ab6bbea9007958d7feaf83360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d50525ab6bbea9007958d7feaf83360">&#9670;&nbsp;</a></span>task_HALL1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void task_HALL1 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task which reads a hall effect sensor. </p>
<p>This task polls the GPIO pin for the hall effect sensor. Whenever the triggers low, the task retains the elapsed time, in milliseconds, between pulses. We use the circumference of the wheel to calculate the distance traveled between pulses, and then divide by the time between pulses to calculate speed, which is subsequently converted to miles per hour. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_params</td><td>A pointer to function parameters which we don't use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a758e3e40f550649d6594bb1c53073dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758e3e40f550649d6594bb1c53073dcc">&#9670;&nbsp;</a></span>updateDriveMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateDriveMode </td>
          <td>(</td>
          <td class="paramtype">EasyNex &amp;&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the drive mode on the Nextion. </p>
<p>This function updates the drive mode on the Nextion display. The user can change the drive mode in two ways: by pressing one of the four buttons, or pressing one of five virtual switches on the touch screen (the fifth button is for pedal charge mode). This function first checks if the user has toggled a switch on the screen by checking a flag in the Nextion software: page2.va1.val. va1 is a boolean flag in the Nextion software that belongs to Page 2 (the switch board page). This function checks its value by reading the variable's attribute: val. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The Nextion display that we are interfacing with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7a7e37eb41ab30ce2710027597139689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7e37eb41ab30ce2710027597139689">&#9670;&nbsp;</a></span>accumulatorPressure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Share&lt;int32_t&gt; accumulatorPressure</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inter-task variable for storing accumulator pressure values. </p>
<p>Storing these values in a Share makes up for any mismatch in transmission frequencies between the PLC and this controller. </p>

</div>
</div>
<a id="a51293a47184005045b60439ff7c77a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51293a47184005045b60439ff7c77a22">&#9670;&nbsp;</a></span>bikeSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Share&lt;int32_t&gt; bikeSpeed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inter-task variable for storing bike speed values. </p>
<p>Storing these values in a Share makes up for any mismatch in transmission frequencies between the display and hall effect tasks. </p>

</div>
</div>
<a id="a6f55d9204fc41e23568a392aab638239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f55d9204fc41e23568a392aab638239">&#9670;&nbsp;</a></span>CANconnected</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Share&lt;bool&gt; CANconnected</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share that stores status of CAN connection. </p>
<p>A value of TRUE means that a CAN connection is established, and a value of FALSE means that an error has occured. </p>

</div>
</div>
<a id="a333f898c62a70650d62a55626c12a6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333f898c62a70650d62a55626c12a6be">&#9670;&nbsp;</a></span>floatSpeed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Share&lt;int32_t&gt; floatSpeed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inter-task variable for storing "float" speed values. </p>
<p>The Nextion display is incapable of working with floating-point numbers. Instead, Nextion Editor has a way of "faking" floating point numbers by splicing an integer with an artifical decimal point, and then shifting it around to simulate a decimal number. Therefore, to display a the vehicle speed in the format, XX.X, we can multiply the calculated speed by 10, and then the Nextion will shift the decimal place left by 1. For example, if <a class="el" href="Interface_8cpp.html#a6d50525ab6bbea9007958d7feaf83360" title="Task which reads a hall effect sensor.">task_HALL1()</a> were to calculate a speed of 10.52 mph, the task will first multiply by 10 and then round to the nearest integer, which will equal 105. Then, <a class="el" href="Interface_8cpp.html#ab33e4972e861b45fe133b914aaec9677" title="Task which interacts with the Nextion display.">task_display()</a> will send the number 105 to the Nextion. The Nextion's software will store the number 105 in its simulated floating point number variable, with a decimal point inserted 1 digit to the left. Thus, the screen will display: 10.5. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Interface_8cpp.html">Interface.cpp</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
